st_coordinates(AP_Tahuayo_UTM)
# match the names to "y"  "occ.covs" "det.covs" "coords"
data_list <- list(y = transposed_array, # Historias de detecci贸n
occ.covs = sitecovs, #covs de sitio
det.covs  = list(effort = DetHist_list[[1]]$effort),
coords = st_coordinates(AP_Tahuayo_UTM)[,1:2]
)  # agregamos el esfuerzo de muestreo como covariable de observaci贸n
# 2. Model fitting --------------------------------------------------------
# Fit a non-spatial, single-species occupancy model.
out <- msPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort) , # Ordinal.day + I(Ordinal.day^2) + Year
data = data_list,
n.samples = 5000,
n.thin = 2,
n.burn = 3000,
n.chains = 3,
n.report = 500)
# Fit a spatial, single-species occupancy model using
# latent factors.
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort) , # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 400,
batch.length = 25,
n.thin = 5,
n.burn = 5000,
n.chains = 1,
NNGP = TRUE,
n.factors = 5,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100)
data.list$coords
st_coordinates(AP_Tahuayo_UTM)[,1:2]
# Fit a spatial, single-species occupancy model using
# latent factors.
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 400,
batch.length = 25,
n.thin = 5,
n.burn = 5000,
n.chains = 1,
NNGP = TRUE,
n.factors = 5,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100)
dim(st_coordinates(AP_Tahuayo_UTM)[,1:2])
dim(sitecovs)
dim(coords)
st_coordinates(Per_full_sf_UTM)
# match the names to "y"  "occ.covs" "det.covs" "coords"
data_list <- list(y = transposed_array, # Historias de detecci贸n
occ.covs = sitecovs, #covs de sitio
det.covs  = list(effort = DetHist_list[[1]]$effort),
coords = st_coordinates(Per_full_sf_UTM)
)  # agregamos el esfuerzo de muestreo como covariable de observaci贸n
# Fit a spatial, single-species occupancy model using
# latent factors.
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 400,
batch.length = 25,
n.thin = 5,
n.burn = 5000,
n.chains = 1,
NNGP = TRUE,
n.factors = 5,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100)
# 3. Model validation -----------------------------------------------------
# Perform a posterior predictive check to assess model fit.
ppc.out <- ppcOcc(out, fit.stat = 'freeman-tukey', group = 1)
# 3. Model validation -----------------------------------------------------
# Perform a posterior predictive check to assess model fit.
ppc.out <- ppcOcc(out, fit.stat = 'freeman-tukey', group = 1)
ppc.out.sp <- ppcOcc(out.sp, fit.stat = 'freeman-tukey', group = 1)
# 4. Model comparison -----------------------------------------------------
# Compute Widely Applicable Information Criterion (WAIC)
# Lower values indicate better model fit.
waicOcc(out)
waicOcc(out.sp)
class(waicOcc(out.sp))
# Extraemos lo tabla de valores estimados
modresult <- as.data.frame(waicOcc(out.sp))
# View(modresult)
DT::datatable(round(summary(fit.commu)$statistics, 3))
# View(modresult)
DT::datatable(modresult)
# View(modresult)
DT::datatable(t(modresult))
modresult
waicOcc(out.sp)
# Extraemos lo tabla de valores estimados
modresult <- as.data.frame(c(waicOcc(out),
waicOcc(out.sp)))
# View(modresult)
DT::datatable(t(modresult))
# Extraemos lo tabla de valores estimados
modresult <- as.data.frame(cbinb(waicOcc(out),
waicOcc(out.sp)))
# Extraemos lo tabla de valores estimados
modresult <- cbinb(as.data.frame(waicOcc(out)),
as.data.frame(waicOcc(out.sp)))
# Extraemos lo tabla de valores estimados
modresult <- cbind(as.data.frame(waicOcc(out)),
as.data.frame(waicOcc(out.sp)))
# View(modresult)
DT::datatable(t(modresult))
library(MCMCvis)
library(coda)
MCMCtrace(out.sp, params = c("beta.ranef.cont.border_dist.mean"), type = 'trace', pdf = F, Rhat = TRUE, n.eff = TRUE)
out.sp
# 5. Posterior summaries --------------------------------------------------
# Concise summary of main parameter estimates
summary(out, level = 'community')
summary(out, level = 'species')
summary(out, level = 'both')
# Create simple plot summaries using MCMCvis package.
# Occupancy community-level effects
MCMCplot(out$beta.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
# Detection covariate effects ---------
MCMCplot(out$alpha.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
# 5. Posterior summaries --------------------------------------------------
# Concise summary of main parameter estimates
summary(out, level = 'community')
summary(out, level = 'species')
summary(out, level = 'both')
# Create simple plot summaries using MCMCvis package.
# Detection covariate effects ---------
MCMCplot(out.sp$alpha.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
# Occupancy community-level effects
MCMCplot(out.sp$beta.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
summary(out, level = 'species')
out.sp$beta.samples
# Occupancy species-level effects
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
str(out.sp$beta.samples)
names(out.sp$beta.samples)
(out.sp$beta.samples)
out.sp$beta.samples[10:20]
out.sp$beta.samples[10:20,]
str(out.sp$beta.samples)
tictoc::tic()
out.sp.gaus <- sfMsPGOcc(occ.formula = ~ scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 400,
batch.length = 25,
n.thin = 5,
n.burn = 5000,
n.chains = 1,
NNGP = TRUE,
n.factors = 5,
n.neighbors = 15,
cov.model = 'gaussian',
n.report = 100);beep(sound = 4)
tictoc::toc()
# Resultados --------------------------------------------------------------
# Extraemos lo tabla de valores estimados
modresult <- cbind(as.data.frame(waicOcc(out)),
as.data.frame(waicOcc(out.sp)),
as.data.frame(waicOcc(out.sp.gaus))
)
# View(modresult)
DT::datatable(t(modresult))
summary(out.sp$lambda.samples)
summary(out.sp$lambda.samples)
ppc.out.sp
summary(ppc.out.sp)
waicOcc(out.sp)
waicOcc(out.sp, by.sp = TRUE)
out.sp$run.time
out.sp$psi.samples
MCMCplot(out.sp$alpha.samples, ref_ovl = TRUE, ci = c(50, 95))
MCMCplot(out.sp$psi.samples, ref_ovl = TRUE, ci = c(50, 95))
MCMCplot(out.sp$lambda.samples, ref_ovl = TRUE, ci = c(50, 95))
MCMCplot(out.sp$z.samples, ref_ovl = TRUE, ci = c(50, 95))
# Occupancy species-level effects
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
# 6. Prediction -----------------------------------------------------------
# Predict occupancy along a gradient of elev
# Create a set of values across the range of observed elev values
elev.pred.vals <- seq(min(data_list$occ.covs$elev),
max(data.list$occ.covs$elev),
length.out = 100)
# 6. Prediction -----------------------------------------------------------
# Predict occupancy along a gradient of elev
# Create a set of values across the range of observed elev values
elev.pred.vals <- seq(min(data_list$occ.covs$elev),
max(data_list$occ.covs$elev),
length.out = 100)
# Scale predicted values by mean and standard deviation used to fit the model
elev.pred.vals.scale <- (elev.pred.vals - mean(data.list$occ.covs$elev)) /
sd(data.list$occ.covs$elev)
names(data_list$occ.covs)
# Predict occupancy across elev  values at mean values of all other variables
pred.df <- as.matrix(data.frame(intercept = 1, elev = elev.pred.vals.scale,
border_dist = 0 ))#, catchment = 0, density = 0,
# slope = 0))
out.sp.pred <- predict(out.sp, pred.df)
as.matrix(elevation_17)
as.matrix(elevation_17[, c('Easting', 'Northing')])
hbefElev
class(hbefElev)
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
library(MCMCvis)
length(out.sp$alpha.comm.samples)
out.sp$n.chains
# Trace plots to check chain mixing. Extract posterior samples and bind in a single matrix.
POSTERIOR.MATRIX <- cbind(out.sp$alpha.comm.samples,
out.sp$beta.comm.samples,
out.sp$alpha.samples,
out.sp$beta.samples)
# Matrix output is all chains combined, split into 3 chains.
CHAIN.1 <- as.mcmc(POSTERIOR.MATRIX[1:2000,])
length(POSTERIOR.MATRIX)
length(POSTERIOR.MATRIX)/3
# 2. Model fitting --------------------------------------------------------
# Fit a non-spatial, single-species occupancy model.
out <- msPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort) , # Ordinal.day + I(Ordinal.day^2) + Year
data = data_list,
n.samples = 5000,
n.thin = 10,
n.burn = 5000,
n.chains = 3,
n.report = 1000);beep(sound = 4)
# 2. Model fitting --------------------------------------------------------
# Fit a non-spatial, single-species occupancy model.
out <- msPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort) , # Ordinal.day + I(Ordinal.day^2) + Year
data = data_list,
n.samples = 10000,
n.thin = 10,
n.burn = 5000,
n.chains = 3,
n.report = 1000);beep(sound = 4)
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 3000,
batch.length = 25,
n.thin = 10,
n.burn = 5000,
n.chains = 3,
NNGP = TRUE,
n.factors = 3,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100);beep(sound = 4)
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 1000,
batch.length = 25,
n.thin = 10,
n.burn = 5000,
n.chains = 3,
NNGP = TRUE,
n.factors = 3,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100);beep(sound = 4)
400*25
5000/25
500*25
25*4000
500*25
600*25
out.sp <- sfMsPGOcc(occ.formula = ~ scale(elev) + scale(border_dist) ,
det.formula = ~ scale(effort), # Ordinal.day + I(Ordinal.day^2) + Year,
data = data_list,
n.batch = 600,
batch.length = 25, # iter=600*25
n.thin = 10,
n.burn = 5000,
n.chains = 3,
NNGP = TRUE,
n.factors = 3,
n.neighbors = 15,
cov.model = 'exponential',
n.report = 100);beep(sound = 4)
out.sp$n.samples
600*25
# Calculate a Bayesian p-value as a simple measure of Goodness of Fit.
# Bayesian p-values between 0.1 and 0.9 indicate adequate model fit.
summary(ppc.out)
summary(ppc.out.sp)
# 4. Model comparison -----------------------------------------------------
# Compute Widely Applicable Information Criterion (WAIC)
# Lower values indicate better model fit.
waicOcc(out)
# 4. Model comparison -----------------------------------------------------
# Compute Widely Applicable Information Criterion (WAIC)
# Lower values indicate better model fit.
waicOcc(out)
waicOcc(out.sp)
# save the results to not run again
save(out, file="C:/CodigoR/Occu_APs_all/blog/2025-10-15-analysis/result/result_2.R") # guardamos los resultados para no correr de nuevo
# save the results to not run again
save(out.sp, file="C:/CodigoR/Occu_APs_all/blog/2025-10-15-analysis/result/sp_result_2.R") # guardamos los resultados para no correr de nuevo
# Create simple plot summaries using MCMCvis package.
# Detection covariate effects ---------
MCMCplot(out.sp$alpha.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
# Occupancy community-level effects
MCMCplot(out.sp$beta.comm.samples, ref_ovl = TRUE, ci = c(50, 95))
# Occupancy species-level effects
MCMCplot(out.sp$beta.samples, ref_ovl = TRUE, ci = c(50, 95))
# Trace plots to check chain mixing. Extract posterior samples and bind in a single matrix.
POSTERIOR.MATRIX <- cbind(out.sp$alpha.comm.samples,
out.sp$beta.comm.samples,
out.sp$alpha.samples,
out.sp$beta.samples)
dim(POSTERIOR.MATRIX)
# Matrix output is all chains combined, split into 3 chains.
CHAIN.1 <- as.mcmc(POSTERIOR.MATRIX[1:1000,])
CHAIN.2 <- as.mcmc(POSTERIOR.MATRIX[1001:2000,])
CHAIN.3 <- as.mcmc(POSTERIOR.MATRIX[2001:3000,])
# Bind four chains as coda mcmc.list object.
POSTERIOR.CHAINS <- mcmc.list(CHAIN.1, CHAIN.2, CHAIN.3)#, CHAIN.4)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "all", Rhat = TRUE, n.eff = TRUE, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "all", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
str(POSTERIOR.CHAINS)
mcmc_trace(POSTERIOR.CHAINS,  pars = c("scale(elev)"), n_warmup = 5000,
facet_args = list(nrow = 2, labeller = label_parsed))
mcmc_trace(POSTERIOR.CHAINS,  pars = c("scale(elev)"),  labeller = label_parsed))
mcmc_trace(POSTERIOR.CHAINS,  pars = c("scale(elev)"),  labeller = label_parsed)
mcmc_trace(POSTERIOR.CHAINS,  pars = c("scale(elev)"))
plot(out.sp$beta.samples[, 1:7], density = FALSE)
plot(out.sp$beta.samples[, 1:4], density = FALSE)
plot(out.sp$beta.samples[, 1:3], density = FALSE)
plot(out.sp$beta.samples[, 3], density = FALSE)
plot(out.sp$beta.samples[, 2:3], density = FALSE)
plot(out.sp$beta.samples[, 1:3], density = FALSE)
plot(out.sp$beta.samples[, 1:4], density = FALSE)
plot(out.sp, 'lambda', density = FALSE)
plot(out.sp, 'lambda', density = FALSE)
plot(out.sp, 'lambda', density = FALSE)
plot(out.sp, 'lambda', density = FALSE)
mcmc_intervals(out.sp)
MCMCtrace(out.sp)
mcmc_intervals(POSTERIOR.CHAINS)
MCMCtrace(POSTERIOR.CHAINS, params = "alpha", Rhat = TRUE, n.eff = TRUE)
MCMCtrace(POSTERIOR.CHAINS, params = "lambda", Rhat = TRUE, n.eff = TRUE)
MCMCtrace(POSTERIOR.CHAINS, params = "Tapirus terrestris", Rhat = TRUE, n.eff = TRUE)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "all", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "scale(elev", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "scale(elev)", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(POSTERIOR.CHAINS, pars = c( "scale(elev)"),point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp, pars = c( "scale(elev)"), point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$lambda.samples , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$psi.samples , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$theta.samples , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$z.samples , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[1:10] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[1:10,] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,1:10] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,10:20] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,10:40] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,23:40] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,23:45] , point_est = "mean",)
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
mcmc_intervals(out.sp$beta.samples[,23:44] , point_est = "mean",)
44-23
mcmc_intervals(out.sp$beta.samples[,23:44] , point_est = "mean",
prob = 0.75, prob_outer = 0.95)
mcmc_intervals(out.sp$beta.samples[,23:44] , point_est = "mean",
prob = 0.75, prob_outer = 0.95)
45+21
mcmc_intervals(out.sp$beta.samples[,45:66] , point_est = "mean",
prob = 0.75, prob_outer = 0.95)
#| eval: true
#| echo: true
#| code-fold: true
#| warning: false
#| message: false
# Extract posterior draws for later use
posterior1 <- as.array(out.sp)
# Trace plots to check chain mixing. Extract posterior samples and bind in a single matrix.
POSTERIOR.MATRIX <- cbind(out.sp$alpha.comm.samples,
out.sp$beta.comm.samples,
out.sp$alpha.samples,
out.sp$beta.samples)
# Matrix output is all chains combined, split into 3 chains.
CHAIN.1 <- as.mcmc(POSTERIOR.MATRIX[1:1000,])
CHAIN.2 <- as.mcmc(POSTERIOR.MATRIX[1001:2000,])
CHAIN.3 <- as.mcmc(POSTERIOR.MATRIX[2001:3000,])
# CHAIN.4 <- as.mcmc(POSTERIOR.MATRIX[8001:10000,])
# Bind four chains as coda mcmc.list object.
POSTERIOR.CHAINS <- mcmc.list(CHAIN.1, CHAIN.2, CHAIN.3)#, CHAIN.4)
# Create an empty folder.
# dir.create ("Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "all", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
#| eval: true
#| echo: true
#| code-fold: true
#| warning: false
#| message: false
# Extract posterior draws for later use
posterior1 <- as.array(out.sp)
# Trace plots to check chain mixing. Extract posterior samples and bind in a single matrix.
POSTERIOR.MATRIX <- cbind(out.sp$alpha.comm.samples,
out.sp$beta.comm.samples,
out.sp$alpha.samples,
out.sp$beta.samples)
# Matrix output is all chains combined, split into 3 chains.
CHAIN.1 <- as.mcmc(POSTERIOR.MATRIX[1:1000,])
CHAIN.2 <- as.mcmc(POSTERIOR.MATRIX[1001:2000,])
CHAIN.3 <- as.mcmc(POSTERIOR.MATRIX[2001:3000,])
# CHAIN.4 <- as.mcmc(POSTERIOR.MATRIX[8001:10000,])
# Bind four chains as coda mcmc.list object.
POSTERIOR.CHAINS <- mcmc.list(CHAIN.1, CHAIN.2, CHAIN.3)#, CHAIN.4)
# Create an empty folder.
# dir.create ("Beetle_plots")
# Plot chain mixing of each parameter to a multi-panel plot and save to the new folder. ART 5 mins
MCMCtrace(POSTERIOR.CHAINS, params = "all", Rhat = TRUE, n.eff = TRUE)#, pdf = TRUE, filename = "Beetle_240909_traceplots.pdf", wd = "Beetle_plots")
#mcmc_trace(fit.commu, parms = c("beta.ranef.cont.border_dist.mean"))
#posterior2 <- extract(fit.commu, inc_warmup = TRUE, permuted = FALSE)
#color_scheme_set("mix-blue-pink")
#p <- mcmc_trace(posterior1,  pars = c("mu", "tau"), n_warmup = 300,
#                facet_args = list(nrow = 2, labeller = label_parsed))
#p + facet_text(size = 15)
#outMCMC <- fit.commu #Convert output to MCMC object
#diagnostics chains
# all as pdf
# MCMCtrace(outMCMC)
# MCMCtrace(outMCMC, params = c("alpha0"), type = 'trace', Rhat = TRUE, n.eff = TRUE)
# MCMCtrace(outMCMC, params = c("beta0"), type = 'trace', Rhat = TRUE, n.eff = TRUE)
# MCMCtrace(outMCMC, params = c("beta.ranef.cont.border_dist"), type = 'trace', Rhat = TRUE, n.eff = TRUE)
# MCMCtrace(out.sp, params = c("beta.ranef.cont.border_dist.mean"), type = 'trace', pdf = F, Rhat = TRUE, n.eff = TRUE)
# MCMCtrace(outMCMC, params = c("beta.ranef.cont.elev"), type = 'trace', Rhat = TRUE, n.eff = TRUE)
# MCMCtrace(outMCMC, params = c("beta.ranef.cont.elev.mean"), type = 'trace', pdf = F, Rhat = TRUE, n.eff = TRUE)
### density
# MCMCtrace(outMCMC, params = c("Nspecies"), ISB = FALSE, pdf = F, exact = TRUE, post_zm = TRUE, type = 'density', Rhat = TRUE, n.eff = TRUE, ind = TRUE)
### density
# MCMCtrace(outMCMC, params = c("beta.ranef.cont.elev.mean"), ISB = FALSE, pdf = F, exact = TRUE, post_zm = TRUE, type = 'density', Rhat = TRUE, n.eff = TRUE, ind = TRUE)
### density
#MCMCtrace(outMCMC, params = c("beta.ranef.cont.border_dist.mean"), ISB = FALSE, pdf = F, exact = TRUE, post_zm = TRUE, type = 'density', Rhat = TRUE, n.eff = TRUE, ind = TRUE)
#coda::gelman.diag(outMCMC,  multivariate = FALSE, transform=FALSE)
# coda::gelman.plot(outMCMC,  multivariate = FALSE)
library(bayesplot)
#mcmc_areas(outMCMC, regex_pars = "Nspecies_in_AP")
# mcmc_areas(outMCMC, regex_pars = "Nspecies_in_AP")
mcmc_intervals(out.sp$beta.samples[,23:44] , point_est = "mean",
prob = 0.75, prob_outer = 0.95)
mcmc_intervals(out.sp$beta.samples[,45:66] , point_est = "mean",
prob = 0.75, prob_outer = 0.95)
#
# mcmc_intervals(outMCMC, pars = c("Nspecies_in_AP[1]",
#                                  "Nspecies_in_AP[2]"),
#                point_est = "mean",
#                prob = 0.75, prob_outer = 0.95) +
#   ggtitle("Number of species") +
#   scale_y_discrete(labels = c("Nspecies_in_AP[1]"=levels(sitecovs$in_AP)[1],
#              "Nspecies_in_AP[2]"=levels(sitecovs$in_AP)[2]))
#
# #Continuous
# p <- mcmc_intervals(outMCMC,
#                pars = c("beta.ranef.cont.border_dist.mean",
#                          #"beta.ranef.cont.elev.mean",
#                         "beta.ranef.categ.in_AP.mean[2]"))
#
# # relabel parameters
# p + scale_y_discrete(
#   labels = c("beta.ranef.cont.border_dist.mean"="Dist_border",
#                          #"beta.ranef.cont.elev.mean"="Elevation",
#                         "beta.ranef.categ.in_AP.mean[2]"="in_AP")
# ) +
#   ggtitle("Treatment effect on all species")
#
mcmc_intervals(out.sp$beta.samples[,45:66] , point_est = "mean",
prob = 0.75, prob_outer = 0.95) +
geom_vline(xintercept = 0, color = "red", linetype = "dashed", size = 1)
mcmc_intervals(out.sp$beta.samples[,45:66] , point_est = "mean",
prob = 0.75, prob_outer = 0.95) +
geom_vline(xintercept = 0, color = "red", linetype = "dashed", size = 0.5)
elevation_17
# Convert the SpatRaster to a data frame with coordinates
df_coords <- as.data.frame(elevation_17, xy = TRUE)
df_coords
quarto version
version
quarto
quarto()
